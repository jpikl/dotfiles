#!/usr/bin/env bash

set -euo pipefail

source "$BASH_LIB_DIR/core.sh"
source "$BASH_LIB_DIR/system.sh"

readonly ERR_NO_VALUES=2

help() {
  cat <<-EOT
		Let user choose value(s). Simple fzf frontend with Bash fallback.

		Usage:
		  $(self) [options] [--] [value]...

		Options:
		  -p <prompt>   Message to print as a prompt.
		  -d <default>  Default value to print if nothing was chosen.
		  -m            Enable selection of multiple values.
		  -z            Values from stdin are delimited by NUL instead of LF.
		  -Z            Print results delimited by NUL instead of LF.
		  -b            Force pure Bash interface instead of fzf.
		  -h            Print this help.

		Value:
		  Zero or more values to select from.
		  Ignored when a command is piped to $(self).
		  In that case, $(self) reads values from stdin (one per line).

		Exit status:
		  0  Normal exit.
		  1  Error.
		  2  No values.

		Environment variables:
		  TTY  Filename of a current TTY device.
		       Used by basic interface when reading from stdin.

		Links:
		  fzf  https://github.com/junegunn/fzf
	EOT
}

main() {
  local prompt=
  local default=
  local multi=false
  local null_in=false
  local null_out=false
  local basic=false
  local opt

  while getopts ":p:d:mzZbh" opt; do
    case "$opt" in
      p) prompt=$OPTARG ;;
      d) default=$OPTARG ;;
      m) multi=true ;;
      z) null_in=true ;;
      Z) null_out=true ;;
      b) basic=true ;;
      h) help; exit ;;
      *) die_invalid_opt "$opt" ;;
    esac
  done

  shift $((OPTIND - 1))

  local values=("$@")
  local results=()

  if [[ $basic = false ]] && is_command fzf; then
    fzf_mode
  else
    basic_mode
  fi

  if [[ ${#results[@]} -eq 0 ]]; then
    if [[ $default ]]; then
      results=("$default")
    else
      exit $ERR_NO_VALUES
    fi
  fi

  if [[ $null_out = true ]]; then
    printf "%s\0" "${results[@]}"
  else
    printf "%s\n" "${results[@]}"
  fi
}

fzf_mode() {
  local opts=("--exit-0" "--print0")

  if [[ ! -t 0 ]]; then
    export FZF_DEFAULT_COMMAND=cat # To force reading from stdin
    if [[ $null_in = true ]]; then
      opts+=("--read0")
    fi
  elif [[ ${#values[@]} -gt 0 ]]; then
    exec < <(printf "%s\0" "${values[@]}")
    opts+=("--read0")
  else
    exec </dev/null # To fail fast using the --exit-0 option
  fi

  if [[ $multi = true ]]; then
    opts+=("--multi")
  else
    opts+=("--select-1")
  fi

  if [[ $prompt ]]; then
    opts+=("--prompt=$prompt ")
  fi

  mapfile -td '' results < <(fzf "${opts[@]}")
}

basic_mode() {
  if [[ ! -t 0 ]]; then
    if [[ $null_in = true ]]; then
      mapfile -td '' values
    else
      mapfile -t values
    fi
    [[ ${TTY-} ]] || die_no_var TTY # Defined in .bashrc
    exec < "$TTY"  # Redirect stdin back to tty
  fi

  if [[ ${#values[@]} -eq 1 && $multi == false ]]; then
    results=("${values[0]}")
  elif [[ ${#values[@]} -ge 1 ]]; then
    local choice
    while true; do
      if [[ $prompt ]]; then
        echo "$prompt"
      fi
      select choice in "${values[@]}"; do
        if [[ $choice ]]; then
          results+=("$choice")
          if [[ $multi = true ]]; then
            mapfile -td '' values < <(remove_value "$choice" "${values[@]}")
          fi
          break
        fi
      done || break
      if [[ $multi = false || ${#values[@]} -eq 0 ]]; then
        break
      fi
    done
  fi
} >&2

remove_value() {
  local value=$1
  shift
  printf "%s\0" "$@" | grep --null \
                            --null-data \
                            --invert-match \
                            --line-regexp \
                            --fixed-strings \
                            "$value"
}

main "$@"
