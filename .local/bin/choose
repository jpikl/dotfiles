#!/usr/bin/env bash

set -euo pipefail

source "$BASH_LIB_DIR/core.sh"
source "$BASH_LIB_DIR/args.sh"
source "$BASH_LIB_DIR/utils.sh"

readonly ERR_NO_VALUES=2
readonly ERR_CANCELED=3

help() {
  cat <<-EOT
		Let user select one from multiple values and print it.
    Uses fzf command by default if available.

		Usage:
		  $(self) [options] [--] [value]...

		Options:
		  -p <prompt>   Message to print as a prompt.
		  -d <default>  Default value to print if no values are available.
		  -i            Read lines from stdin as values.
		  -0            Expect stdin values to be separated by null character.
		  -b            Use basic interface instead of fzf.
		  -h            Display this help.

		Value:
		  Zero or more values to select from.
      Ignored when the -i option is used.

		Exit status:
		  0  Normal exit.
		  1  Error.
		  2  No values.
		  3  Canceled by user.

		Links:
		  fzf  https://github.com/junegunn/fzf
	EOT
}

init() {
  local opt

  while getopts "p:d:i0bh" opt; do
    case "$opt" in
      p) prompt=$OPTARG ;;
      d) default=$OPTARG ;;
      i) stdin=true ;;
      0) null=true ;;
      b) basic=true ;;
      h) help; exit ;;
      *) die_invalid_opt "$opt" ;;
    esac
  done

  shift $((OPTIND - 1))
  values=("$@")
}

run() {
  local result=

  if [[ $basic = false ]] && is_command fzf; then
    fzf_mode
  else
    basic_mode
  fi

  if [[ $result ]]; then
    echo "$result"
  elif [[ $default ]]; then
    echo "$default"
  else
    exit $ERR_NO_VALUES
  fi
}

fzf_mode() {
  local opts=("--layout=reverse" "--select-1" "--exact")

  if [[ $stdin = true ]]; then
    export FZF_DEFAULT_COMMAND=cat # To force reading from stdin
  else
    exec < <(printf "%s\0" "${values[@]}")
  fi

  if [[ $stdin = false || $null = true ]]; then
    opts+=("--read0")
  fi

  if [[ $prompt ]]; then
    opts+=("--prompt=$prompt ")
  fi

  local error=
  result=$(fzf "${opts[@]}") || error=$?

  if [[ $error -eq 130 ]]; then
    exit $ERR_CANCELED
  elif [[ $error -gt 1 ]]; then
    exit "$ERR_GENERIC"
  fi
}

basic_mode() {
  if [[ $stdin = true ]]; then
    if [[ $null = true ]]; then
      mapfile -t -d '' values
    else
      mapfile -t values
    fi
    [[ $TTY ]] || die "expected TTY variable to be defined" # Defined in .bashrc
    exec < "$TTY"  # Redirect stdin back to tty
  fi

  if [[ ${#values[@]} -eq 1 ]]; then
    result=${values[0]}
  elif [[ ${#values[@]} -gt 1 ]]; then
    [[ $prompt ]] && echo "$prompt" >&2
    select result in "${values[@]}"; do
      [[ $result ]] && break
    done || exit $ERR_CANCELED
  fi
}

main() {
  local prompt=
  local default=
  local stdin=false
  local null=false
  local basic=false
  local values

  init "$@"
  run
}

main "$@"
