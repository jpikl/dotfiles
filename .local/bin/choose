#!/usr/bin/env bash

set -euo pipefail

source "$BASH_LIB_DIR/core.sh"
source "$BASH_LIB_DIR/utils.sh"

readonly ERR_NO_VALUES=2

help() {
  cat <<-EOT
		Let user select one from multiple values and print it.
    Uses fzf command by default if available.

		Usage:
		  $(self) [options] [--] [value]...

		Options:
		  -p <prompt>   Message to print as a prompt.
		  -d <default>  Default value to print if no values are available.
		  -m            Enable selection of multiple values.
		  -i            Read values from standard input.
		  -z            Read values delimited by NUL character instead of newline.
		  -Z            Print results delimited by NUL character instead of newline.
		  -b            Force basic interface instead of fzf.
		  -h            Display this help.

		Value:
		  Zero or more values to select from.
		  Ignored when the -i option is used.

		Exit status:
		  0  Normal exit.
		  1  Error.
		  2  No values.

		Links:
		  fzf  https://github.com/junegunn/fzf
	EOT
}

main() {
  local prompt=
  local default=
  local multi=false
  local stdin=false
  local null_in=false
  local null_out=false
  local basic=false
  local opt

  while getopts ":p:d:mizZbh" opt; do
    case "$opt" in
      p) prompt=$OPTARG ;;
      d) default=$OPTARG ;;
      m) multi=true ;;
      i) stdin=true ;;
      z) null_in=true ;;
      Z) null_out=true ;;
      b) basic=true ;;
      h) help; exit ;;
      *) die_invalid_opt "$opt" ;;
    esac
  done

  shift $((OPTIND - 1))

  local values=("$@")
  local results=()

  if [[ $basic = false ]] && is_command fzf; then
    fzf_mode
  else
    basic_mode
  fi

  if [[ ${#results[@]} -eq 0 ]]; then
    if [[ $default ]]; then
      results=("$default")
    else
      exit $ERR_NO_VALUES
    fi
  fi

  if [[ $null_out = true ]]; then
    printf "%s\0" "${results[@]}"
  else
    printf "%s\n" "${results[@]}"
  fi
}

fzf_mode() {
  local opts=("--select-1" "--exit-0" "--print0")

  if [[ $stdin = true ]]; then
    export FZF_DEFAULT_COMMAND=cat # To force reading from stdin
    [[ $null_in = true ]] && opts+=("--read0")
  elif [[ ${#values[@]} -gt 0 ]]; then
    exec < <(printf "%s\0" "${values[@]}")
    opts+=("--read0")
  else
    exec </dev/null # To fail fast using the --exit-0 option
  fi

  [[ $multi = true ]] && opts+=("--multi")
  [[ $prompt ]] && opts+=("--prompt=$prompt ")

  mapfile -td '' results < <(fzf "${opts[@]}")
}

basic_mode() {
  if [[ $stdin = true ]]; then
    if [[ $null_in = true ]]; then
      mapfile -td '' values
    else
      mapfile -t values
    fi
    [[ $TTY ]] || die "expected TTY variable to be defined" # Defined in .bashrc
    exec < "$TTY"  # Redirect stdin back to tty
  fi

  if [[ ${#values[@]} -eq 1 ]]; then
    results=("${values[0]}")
  elif [[ ${#values[@]} -gt 1 ]]; then
    local choice
    while true; do
      [[ $prompt ]] && echo "$prompt"
      select choice in "${values[@]}"; do
        if [[ $choice ]]; then
          results+=("$choice")
          if [[ $multi = true ]]; then
            mapfile -td '' values < <(remove_value "$choice" "${values[@]}")
          fi
          break
        fi
      done || break
      [[ $multi = false || ${#values[@]} -eq 0 ]] && break
    done
  fi
} >&2

main "$@"
