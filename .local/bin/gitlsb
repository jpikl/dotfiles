#!/usr/bin/env bash

set -euo pipefail

source "$BASH_LIB_DIR/core.sh"

readonly FORMAT="--format=%(refname:short)"

help() {
  cat <<-EOT
		List git branches.

		Usage:
		  $(self) [options]

		Options:
		  -c  Include current branch.
		  -C  Exclude current branch.
		  -l  Include local branches.
		  -r  Include remote branches.
		  -g  Include tracking branches no longer on remote.
		  -x  Remove remote prefix from branch names.
		  -h  Print this help.
	EOT
}

main() {
  local current=false
  local no_current=false
  local local=false
  local remote=false
  local gone=false
  local no_prefix=false
  local opt

  while getopts ":cClrgxh" opt; do
    case "$opt" in
      c) current=true ;;
      C) no_current=true ;;
      l) local=true ;;
      r) remote=true ;;
      g) gone=true ;;
      x) no_prefix=true ;;
      h) help; exit ;;
      *) die_invalid_opt "$opt" ;;
    esac
  done

  if [[ $current == false
     && $local == false
     && $remote == false
     && $gone == false ]]; then
     die_help "nothing to do"
  fi

  # Just to check we are in a git repository.
  git status --porcelain >/dev/null

  if [[ $no_prefix = true ]]; then
    { # We want to print mix of local and remote branches.
      print_enabled_local
      print_enabled_remote | remove_remote_prefix
    } | LC_ALL=C sort | uniq | remove_enabled_current
  else
    # We want to print local branches before the remote ones.
    print_enabled_local | sort | uniq | remove_enabled_current
    print_enabled_remote | sort
  fi
}

print_enabled_local() {
  [[ $current = true ]] && print_current
  [[ $local = true ]] && print_local
  [[ $gone = true ]] && print_gone
  true
}

print_enabled_remote() {
  [[ $remote = true ]] && print_remote
  true
}

print_current() {
  # "git branch --show-current" requires git >=2.21
  git rev-parse --abbrev-ref HEAD
}

print_local() {
  git branch $FORMAT | grep --invert-match 'HEAD detached' || true
}

print_remote() {
  git branch --remote $FORMAT | grep --invert-match '/HEAD$' || true
}

print_gone() {
  print_local | grep --fixed-strings \
                     --line-regexp \
                     --invert-match \
                     --file=<(print_remote | remove_remote_prefix) || true
}

remove_enabled_current() {
  if [[ $no_current = true ]]; then
    grep --fixed-strings --line-regexp --invert-match "$(print_current)" || true
  else
    cat
  fi
}

remove_remote_prefix() {
  sed --regexp-extended --expression='s/^[^/]*\///'
}

main "$@"
