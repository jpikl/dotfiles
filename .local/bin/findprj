#!/usr/bin/env bash

set -euo pipefail

source "$BASH_LIB_DIR/core.sh"

help() {
  cat <<-EOT
		Find root directories of software projects.

		By default, $(self) searches for all types of projects,
		unless one or more -v,m,n options is passed.

		Usage:
		  $(self) [options] [--] [path]

		Options:
		  -v  Include projects using version control system.
		  -m  Include Maven projects.
		  -n  Include Node.js projects.
		  -u  Search upwards to find the topmost project root.
		  -Z  Print results delimited by NUL instead of LF.
		  -h  Print this help.

		Path:
		  Search starting point.
		  Default path is the current working directory.
	EOT
}

main() {
  local vcs=false
  local maven=false
  local node=false
  local upwards=false
  local null_out=false
  local opt

  while getopts ":vmnuZh" opt; do
    case "$opt" in
      v) vcs=true ;;
      m) maven=true ;;
      n) node=true ;;
      u) upwards=true ;;
      Z) null_out=true ;;
      h) help; exit ;;
      *) die_invalid_opt "$opt" ;;
    esac
  done

  shift $((OPTIND - 1))

  local path="."

  if [[ $# -ge 1 ]]; then
    [[ -d $1 ]] || die "'$1' is not a directory"
    path="$1"
  fi

  local dirs=()
  local files=()

  # Include all by default
  if [[ $vcs == false && $maven == false && $node == false ]]; then
    vcs=true
    maven=true
    node=true
  fi

  if [[ $vcs == true ]]; then
    dirs+=(
      ".git" # Git
      ".hg"  # Mercurial
      ".bzr" # Bazaar
      ".svn" # Subversion
    )
  fi

  if [[ $maven == true ]]; then
   files+=("pom.xml")
  fi

  if [[ $node == true ]]; then
    files+=("package.json")
  fi

  local expression+=("(")

  if [[ ${#dirs[@]} -gt 0 ]]; then
    expression+=("(" "-type" "d" "(")
    for (( i = 0; i < ${#dirs[@]}; i++ )); do
      [[ $i -gt 0 ]] && expression+=("-or")
      expression+=("-name" "${dirs[$i]}")
    done
    expression+=(")" ")")
  fi

  if [[ ${#dirs[@]} -gt 0 && ${#files[@]} -gt 0 ]]; then
    expression+=("-or")
  fi

  if [[ ${#files[@]} -gt 0 ]]; then
    expression+=("(" "-type" "f" "(")
    for (( i = 0; i < ${#files[@]}; i++ )); do
      [[ $i -gt 0 ]] && expression+=("-or")
      expression+=("-name" "${files[$i]}")
    done
    expression+=(")" ")")
  fi

  expression+=(")" "-printf" "%h\0")

  if [[ $upwards == true ]]; then
    find_upwards
  else
    find_downards
  fi
}

find_upwards() {
  findup "$path" "${expression[@]}" \
    | tail --zero-terminated --lines=1 \
    | replace_line_endings \
    | check_any_result \
    || die "unable to find project root"
}

find_downards() {
  # A directory will be printed twice if if contains two different
  # project files, so we are using 'uniq' to merge them.
  findex "$path" -exclude vploD "${expression[@]}" \
    | uniq --zero-terminated \
    | replace_line_endings \
    | check_any_result \
    || die "unable find any project directory"
}

replace_line_endings() {
  if [[ $null_out = false ]]; then
    tr '\0' '\n'
  else
    cat
  fi
}

check_any_result() {
  # We use grep to raise error when nothing is found
  if [[ $null_out = true ]]; then
    grep --null-data --null '.'
  else
    grep '.'
  fi
}

main "$@"
