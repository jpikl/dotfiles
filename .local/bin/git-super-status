#!/usr/bin/env bash

set -euo pipefail

source ~/.local/lib/bash/core.sh
source ~/.local/lib/bash/term.sh

help() {
  cat <<-EOT
		Git status on steroids.

		Usage:
		  $(self) [<options>]

		Options:
		  -a  Include all information.
		  -c  Force colors in output (-C for no colors).
		  -i  Force icons in output (-I for no icons).
		  -F  Exclude all file lists (same as -WSU).
		  -W  Exclude work tree file list.
		  -S  Exclude index file list.
		  -U  Exclude untracked file list.
		  -h  Print this help.

		Environment vars:
		  TERM_ICONS  Enables icons in terminal output (default: false).
	EOT
}

main() {
  local all=false
  local colors_on=
  local icons_on=
  local wtree_files_on=true
  local index_files_on=true
  local untracked_files_on=true
  local opt

  while getopts ":acChiIFWSU" opt; do
    case "$opt" in
      a) all=true ;;
      c) colors_on=true ;;
      C) colors_on=false ;;
      i) icons_on=true ;;
      I) icons_on=false ;;
      F) wtree_files_on=false
         index_files_on=false
         untracked_files_on=false ;;
      W) wtree_files_on=false ;;
      S) index_files_on=false ;;
      U) untracked_files_on=false ;;
      h) help; exit ;;
      *) die_invalid_opt "$opt" ;;
    esac
  done

  # Check we are in a git repository.
  git status --porcelain >/dev/null

  if [[ ! $colors_on ]] ; then
    if term_has_colors; then
      colors_on=true
    else
      colors_on=false
    fi
  fi

  if [[ ! $icons_on ]] ; then
    if term_has_icons; then
      icons_on=true
    else
      icons_on=false
    fi
  fi

  generate_output | replace_formatters
}

generate_output() {
  local local_branch
  local local_commit
  local remote_branch=
  local remote_commit=
  local wtree_state
  local commits_ahead=
  local commits_behind=
  local stash_size

  local_branch=$(print_local_branch)
  local_commit=$(print_local_commit)
  wtree_state=$(git state)
  stash_size=$(print_stash_size)

  if [[ $local_branch ]]; then
    remote_branch=$(print_remote_branch "$local_branch")

    if [[ $remote_branch ]]; then
      remote_commit=$(print_remote_commit "$remote_branch")
      commits_ahead=$(print_commits_ahead "$remote_branch")
      commits_behind=$(print_commits_behind "$remote_branch")
    fi
  fi

  local separate_local_remote
  if [[ ( $remote_branch && $remote_commit != "$local_commit" ) || $all == true ]]; then
    separate_local_remote=true
  else
    separate_local_remote=false
  fi

  if [[ $separate_local_remote == true ]]; then
    printf "[{@loc}{#bld}Local{#rst}]\n"
  fi

  {
    if [[ $local_branch || $all == true ]]; then
      printf "{#bld}Branch{#rst}{@brn}:|%s\n" "${local_branch:--}"
    fi

    if [[ $remote_branch && $separate_local_remote != true ]]; then
      printf "{#bld}Remote{#rst}{@rmt}:|%s\n" "$remote_branch"
    fi

    if [[ $wtree_state || $all == true ]]; then
      printf "{#bld}State{#rst}{@sta}:|%s\n" "${wtree_state:--}"
    fi

    if [[ $commits_ahead -gt 0 || $all == true ]]; then
      printf "{#bld}Ahead{#rst}{@ahd}:|%s\n" "${commits_ahead:--}"
    fi

    if [[ $stash_size -gt 0 || $all == true ]]; then
      printf "{#bld}Stash{#rst}{@sts}:|%s\n" "$stash_size"
    fi

    if [[ $local_commit || $all == true ]]; then
      printf "{#bld}Commit{#rst}{@cmt}:|%s\n" "${local_commit:--}"
    fi

    print_log_table "$local_commit"
  } | format_table --table-right=1

  if [[ $separate_local_remote == true ]]; then
    printf "\n[{@rmt}{#bld}Remote{#rst}]\n"

    {
      printf "{#bld}Branch{#rst}{@brn}:|%s\n" "${remote_branch:--}"

      if [[ $remote_commit != "$local_commit" || $all == true ]]; then
        if [[ $commits_behind -gt 0 || $all == true ]]; then
          printf "{#bld}Ahead{#rst}{@bhd}:|%s\n" "${commits_behind:--}"
        fi

        if [[ $remote_commit || $all == true ]]; then
          printf "{#bld}Commit{#rst}{@cmt}:|%s\n" "${remote_commit:--}"
        fi

        print_log_table "$remote_commit"
      fi

    } | format_table --table-right=1
  fi

  local change_type
  local change_types=(A C D M R T U X B)

  local -A change_codes=(
    [A]="add"
    [C]="cpy"
    [D]="del"
    [M]="mod"
    [R]="ren"
    [T]="ret"
    [U]="unm"
    [X]="unk"
    [B]="brk"
  )

  local -A change_names=(
    [A]="Addded"
    [C]="Copied"
    [D]="Deleted"
    [M]="Modified"
    [R]="Renamed"
    [T]="Retyped"
    [U]="Unmerged"
    [X]="Unknown"
    [B]="Broken"
  )

  local wtree_count
  local index_count

  local is_index_change=false
  local is_wtree_change=false

  local -A wtree_changes_count=()
  local -A index_changes_count=()

  local untracked_files_count

  for change_type in "${change_types[@]}"; do
    wtree_count=$(print_changed_files_count "$change_type")
    index_count=$(print_changed_files_count "$change_type" --staged)

    wtree_changes_count[$change_type]=$wtree_count
    index_changes_count[$change_type]=$index_count

    [[ $wtree_count -gt 0 ]] && is_wtree_change=true
    [[ $index_count -gt 0 ]] && is_index_change=true
  done

  untracked_files_count=$(print_untracked_files_count)

  if [[ $all == true
     || $is_index_change == true
     || $is_wtree_change == true
     || $untracked_files_count -gt 0 ]]; then

    echo
    {
      printf "{#bld}Change{#rst}|{@cht}{____}| {@wtr}| {@idx}\n"

      for change_type in "${change_types[@]}"; do
        wtree_count=${wtree_changes_count[$change_type]}
        index_count=${index_changes_count[$change_type]}

        if [[ $wtree_count -gt 0 || $index_count -gt 0 || $all == true ]]; then
          printf "{#%s}%s{____}|{@%s}{#rst}|{___} %d|{___} %d\n" \
                                       "${change_codes[$change_type]}" \
                                       "${change_names[$change_type]}" \
                                       "${change_codes[$change_type]}" \
                                       "$wtree_count" \
                                       "$index_count"
        fi
      done

      if [[ $untracked_files_count -gt 0 || $all == true ]]; then
        printf "{#unt}Untracked{____}|{@unt}{#rst}|{___} %d|\n" "$untracked_files_count"
      fi
    } | format_table --table-right=1,3,4
  fi

  if [[ $is_wtree_change == true && $wtree_files_on == true ]]; then
    printf "\n{#bld}Changes in work tree{#rst}:\n"

    for change_type in "${change_types[@]}"; do
      if [[ ${wtree_changes_count[$change_type]} -gt 0 ]]; then
        print_changed_files "$change_type" \
          | sort \
          | format_paths "$change_type" "${change_codes[$change_type]}"
      fi
    done
  fi

  if [[ $is_index_change == true && $index_files_on == true ]]; then
    printf "\n{#bld}Changes in index{#rst}:\n"

    for change_type in "${change_types[@]}"; do
      if [[ ${index_changes_count[$change_type]} -gt 0 ]]; then
        print_changed_files "$change_type" --staged \
          | sort \
          | format_paths "$change_type" "${change_codes[$change_type]}"
      fi
    done
  fi

  if [[ $untracked_files_count -gt 0 && $untracked_files_on == true ]]; then
    printf "\n{#bld}Untracked files{#rst}:\n"
    print_untracked_files | sort | format_paths "" "unt"
  fi
}

print_local_branch() {
  git ls-branches -c
}

print_local_commit() {
  # Fails when we are in a repository with no commits
  git rev-parse --verify HEAD 2>/dev/null || true
}

print_remote_branch() {
  # We cannot use {@upstream} notation since it does not work with detached HEAD
  git for-each-ref --format='%(upstream:short)' "refs/heads/$1"
}

print_remote_commit() {
  git rev-parse "$1"
}

print_commits_ahead() {
  git rev-list --count --left-only "HEAD...$1"
}

print_commits_behind() {
  git rev-list --count --right-only "HEAD...$1"
}

print_stash_size() {
  git stash list | wc --lines
}

print_log_table() {
  local message='{#bld}Message{#rst}{@msg}:|'
  local author='{#bld}Author{#rst}{@ath}:|'
  local date='{#bld}Date{#rst}{@dat}:|'

  if [[ $1 ]]; then
    message+="%s"
    author+="%aN <%ae>"
    date+="%ai (%ar)"
    git log -1 --pretty="${message}%n${author}%n${date}" "$1"
  else
    message+="-"
    author+="-"
    date+="-"
    printf "%s\n" "$message" "$author" "$date"
  fi
}

print_changed_files() {
  if [[ $1 == R || $1 == C ]]; then
    print_changed_files_raw "$@" --name-status
  else
    print_changed_files_raw "$@" --name-only
  fi
}

print_changed_files_count() {
  print_changed_files_raw "$@" --name-only | count_nulls
}

print_changed_files_raw() {
  git diff -z --diff-filter "$@"
}

print_untracked_files() {
  git ls-files -z --other --exclude-standard --full-name "$(git rev-parse --show-toplevel)"
}

print_untracked_files_count() {
  print_untracked_files | count_nulls
}

count_nulls() {
  tr --complement --delete '\0' | wc --bytes
}

format_table() {
  column --table --separator="|" --output-separator=" " "$@"
}

format_paths() {
  local change_type=$1
  local change_code=$2

  if [[ $change_type == R || $change_type == C ]]; then
    local status src_path dst_path

    while IFS= read -rd '' status \
       && IFS= read -rd '' src_path \
       && IFS= read -rd '' dst_path; do

      # Remove type character and leading zeros
      status=${status:1}
      while [[ $status == 0* ]]; do
        status=${status:1}
      done

      printf " {#%s}{@%s} %s{#rst}|{@mov}|{#%s}%s{#rst}|{#unt}%s%%{#rst}\n" \
                          "$change_code" \
                          "$change_code" \
                          "$src_path" \
                          "$change_code" \
                          "$dst_path" \
                          "$status"

    done | format_table --table-right=4
  else
    local path
    while IFS= read -rd '' path; do
      printf " {#%s}{@%s} %s{#rst}\n" "$change_code" "$change_code" "$path"
    done
  fi
}

replace_formatters() {
  # Why are we using these color/icon placeholders
  # instead of directly outputing color/icons?
  # 1) It is easy to disable them in the output.
  # 2) All the placeholders have equal lenght and
  #    the "column" command aligns them correctly.

  local -A colors=()
  local -A icons=()

  if [[ $colors_on == true ]]; then
    colors[rst]=$(tput sgr0)      # Reset
    colors[bld]=$(tput bold)      # Bold
    colors[add]="$(tput setaf 2)" # Added
    colors[cpy]="$(tput setaf 6)" # Copied
    colors[del]="$(tput setaf 1)" # Deleted
    colors[mod]="$(tput setaf 4)" # Modified
    colors[ren]="$(tput setaf 6)" # Renamed
    colors[ret]="$(tput setaf 6)" # Retyped
    colors[unm]="$(tput setaf 3)" # Unmerged
    colors[unk]="$(tput setaf 5)" # Unknown
    colors[brk]="$(tput setaf 5)" # Broken
    colors[unt]="$(tput setaf 8)" # Untracked
  else
    colors[rst]= # Reset
    colors[bld]= # Bold
    colors[add]= # Added
    colors[cpy]= # Copied
    colors[del]= # Deleted
    colors[mod]= # Modified
    colors[ren]= # Renamed
    colors[ret]= # Retyped
    colors[unm]= # Unmerged
    colors[unk]= # Unknown
    colors[brk]= # Broken
    colors[unt]= # Untracked
  fi

  if [[ $icons_on == true ]]; then
    icons[loc]=" ﲾ " # Local
    icons[rmt]=" 歷"  # Remote
    icons[brn]="  " # Branch
    icons[ahd]="  " # Ahead
    icons[bhd]="  " # Behind
    icons[sta]="  " # State
    icons[sts]="  " # Stash
    icons[cmt]="  " # Commit
    icons[msg]="  " # Message
    icons[ath]="  " # Author
    icons[dat]="  " # Date
    icons[wtr]="פּ"   # Work tree
    icons[idx]=""   # Index
    icons[cht]=" "  # Change type
    icons[add]=" "  # Added
    icons[cpy]=" "  # Copied
    icons[del]=" "  # Deleted
    icons[mod]=" "  # Modified
    icons[ren]=" "  # Renamed
    icons[ret]=" "  # Retyped
    icons[unm]=" "  # Unmerged
    icons[unk]="? "  # Unknown
    icons[brk]=" "  # Broken
    icons[unt]=" "  # Untracked
    icons[mov]=""   # Move
  else
    icons[loc]=     # Local
    icons[rmt]=     # Remote
    icons[brn]=     # Branch
    icons[ahd]=     # Ahead
    icons[bhd]=     # Behind
    icons[sta]=     # State
    icons[sts]=     # Stash
    icons[cmt]=     # Commit
    icons[msg]=     # Message
    icons[ath]=     # Author
    icons[dat]=     # Date
    icons[wtr]="W"  # Work tree
    icons[idx]="I"  # Index
    icons[cht]="T"  # Change type
    icons[add]="A"  # Added
    icons[cpy]="C"  # Copied
    icons[del]="D"  # Deleted
    icons[mod]="M"  # Modified
    icons[ren]="R"  # Renamed
    icons[ret]="T"  # Retyped
    icons[unm]="U"  # Unmerged
    icons[unk]="X"  # Unknown
    icons[brk]="B"  # Broken
    icons[unt]="?"  # Untracked
    icons[mov]="->" # Move
  fi

  local name
  local sed_opts=()

  # Remove "{___}" expressions which are just used as a padding to deceive
  # the "column" command to correctly align the output.
  sed_opts+=("--expression" "s/{_\+}//g")

  # Replace "{#abc}" expressions by color escape codes.
  for name in "${!colors[@]}"; do
    sed_opts+=("--expression" "s/{#$name}/${colors[$name]}/g")
  done

  # Replace "{@abc}" expressions by icon characters.
  for name in "${!icons[@]}"; do
    sed_opts+=("--expression" "s/{@$name}/${icons[$name]}/g")
  done



  sed "${sed_opts[@]}"
}

main "$@"
