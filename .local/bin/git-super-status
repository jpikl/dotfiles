#!/usr/bin/env bash

set -euo pipefail

source "$BASH_LIB_DIR/core.sh"

help() {
  cat <<-EOT
		Git super status.

		Usage:
		  $(self) [options]

		Options:
		  -a  Include all information.
		  -c  Force colors in output (-C for no colors).
		  -i  Force icons in output (-I for no icons).
		  -F  Exclude all file lists (same as -WSU).
		  -W  Exclude work tree file list.
		  -S  Exclude index file list.
		  -U  Exclude untracked file list.
		  -h  Print this help.

		Environment variables:
		  TERM_COLORS  Enables colors in terminal output (default: true).
		  TERM_ICONS   Enables icons in terminal output (default: false).
	EOT
}

main() {
  local all=false
  local colors_on=false
  local icons_on=false
  local wtree_files_on=true
  local index_files_on=true
  local untracked_files_on=true
  local opt

  if [[ -t 1 ]]; then
    colors_on=${TERM_COLORS:-true}
    icons_on=${TERM_ICONS:-true}
  fi

  while getopts ":acChiIFWSU" opt; do
    case "$opt" in
      a) all=true ;;
      c) colors_on=true ;;
      C) colors_on=false ;;
      i) icons_on=true ;;
      I) icons_on=false ;;
      F) wtree_files_on=false
         index_files_on=false
         untracked_files_on=false ;;
      W) wtree_files_on=false ;;
      S) index_files_on=false ;;
      U) untracked_files_on=false ;;
      h) help; exit ;;
      *) die_invalid_opt "$opt" ;;
    esac
  done

  # Check we are in a git repository.
  git status --porcelain >/dev/null

  generate_output | replace_formatters
}

generate_output() {
  local local_branch
  local local_commit
  local remote_branch=
  local remote_commit=
  local wtree_state
  local commits_ahead=
  local commits_behind=
  local stash_size

  local_branch=$(print_local_branch)
  local_commit=$(print_local_commit)
  wtree_state=$(git state)
  stash_size=$(print_stash_size)

  if [[ $local_branch ]]; then
    remote_branch=$(print_remote_branch "$local_branch")

    if [[ $remote_branch ]]; then
      remote_commit=$(print_remove_commit "$remote_branch")
      commits_ahead=$(print_commits_ahead "$remote_branch")
      commits_behind=$(print_commits_behind "$remote_branch")
    fi
  fi

  printf "===== *l#bLOCAL#r =====\n\n"

  {
    if [[ $local_branch || $all == true ]]; then
      printf "#bBranch#r*h:|%s\n" "${local_branch:--}"
    fi

    if [[ $wtree_state || $all == true ]]; then
      printf "#bState#r*e:|%s\n" "${wtree_state:--}"
    fi

    if [[ $commits_ahead -gt 0 || $all == true ]]; then
      printf "#bAhead#r*a:|%s\n" "${commits_ahead:--}"
    fi

    if [[ $stash_size -gt 0 || $all == true ]]; then
      printf "#bStash#r*s:|%s\n" "$stash_size"
    fi

    if [[ $local_commit || $all == true ]]; then
      printf "#bCommit#r*c:|%s\n" "${local_commit:--}"
    fi

    print_log_table "$local_commit"
  } | format_table --table-right=1

  if [[ $remote_branch || $all == true ]]; then
    printf "\n===== *r#bREMOTE#r =====\n\n"

    {
      printf "#bBranch#r*h:|%s\n" "${remote_branch:--}"

      if [[ $remote_commit != "$local_commit" || $all == true ]]; then
        if [[ $commits_behind -gt 0 || $all == true ]]; then
          printf "#bAhead#r*b:|%s\n" "${commits_behind:--}"
        fi

        if [[ $remote_commit || $all == true ]]; then
          printf "#bCommit#r*c:|%s\n" "${remote_commit:--}"
        fi

        print_log_table "$remote_commit"
      fi

    } | format_table --table-right=1
  fi

  local change_type
  local change_types=(A C D M R T U X B)

  local -A change_names=(
    [A]="Addded"
    [C]="Copied"
    [D]="Deleted"
    [M]="Modified"
    [R]="Renamed"
    [T]="Retyped"
    [U]="Unmerged"
    [X]="Unknown"
    [B]="Broken"
  )

  local wtree_count
  local index_count

  local is_index_change=false
  local is_wtree_change=false

  local -A wtree_changes_count=()
  local -A index_changes_count=()

  local untracked_files_count

  for change_type in "${change_types[@]}"; do
    wtree_count=$(print_changed_files_count "$change_type")
    index_count=$(print_changed_files_count "$change_type" --staged)

    wtree_changes_count[$change_type]=$wtree_count
    index_changes_count[$change_type]=$index_count

    [[ $wtree_count -gt 0 ]] && is_wtree_change=true
    [[ $index_count -gt 0 ]] && is_index_change=true
  done

  untracked_files_count=$(print_untracked_files_count)

  if [[ $all == true
     || $is_index_change == true
     || $is_wtree_change == true
     || $untracked_files_count -gt 0 ]]; then

    printf "\n===== *g#bCHANGES#r =====\n\n"

    {
      printf "#bType|*t#r|*w|*i\n"

      for change_type in "${change_types[@]}"; do
        wtree_count=${wtree_changes_count[$change_type]}
        index_count=${index_changes_count[$change_type]}

        if [[ $wtree_count -gt 0 || $index_count -gt 0 || $all == true ]]; then
          printf "#%s%s|*%s#r|%d|%d\n" "$change_type" \
                                       "${change_names[$change_type]}" \
                                       "$change_type" \
                                       "$wtree_count" \
                                       "$index_count"
        fi
      done

      if [[ $untracked_files_count -gt 0 || $all == true ]]; then
        printf "#uUntracked|*u#r|%d|\n" "$untracked_files_count"
      fi
    } | format_table --table-right=1,3,4
  fi

  if [[ $is_wtree_change == true && $wtree_files_on == true ]]; then
    printf "\n#bChanges in work tree#r:\n"

    for change_type in "${change_types[@]}"; do
      if [[ ${wtree_changes_count[$change_type]} -gt 0 ]]; then
        print_changed_files "$change_type" | sort | format_paths "$change_type"
      fi
    done
  fi

  if [[ $is_index_change == true && $index_files_on == true ]]; then
    printf "\n#bChanges in index#r:\n"

    for change_type in "${change_types[@]}"; do
      if [[ ${index_changes_count[$change_type]} -gt 0 ]]; then
        print_changed_files "$change_type" --staged | sort | format_paths "$change_type"
      fi
    done
  fi

  if [[ $untracked_files_count -gt 0 && $untracked_files_on == true ]]; then
    printf "\n#bUntracked files#r:\n"
    print_untracked_files | sort | format_paths "u"
  fi
}

print_local_branch() {
  git ls-branches -c
}

print_local_commit() {
  # Fails when we are in a repository with no commits
  git rev-parse --verify HEAD 2>/dev/null || true
}

print_remote_branch() {
  # We cannot use @{upstream} notation since it does not work with detached HEAD
  git for-each-ref --format='%(upstream:short)' "refs/heads/$1"
}

print_remove_commit() {
  git rev-parse "$1"
}

print_commits_ahead() {
  git rev-list --count --left-only "HEAD...$1"
}

print_commits_behind() {
  git rev-list --count --right-only "HEAD...$1"
}

print_stash_size() {
  git stash list | wc --lines
}

print_log_table() {
  local message='#bMessage#r*m:|'
  local author='#bAuthor#r*o:|'
  local date='#bDate#r*d:|'

  if [[ $1 ]]; then
    message+="%s"
    author+="%aN <%ae>"
    date+="%ai (%ar)"
    git log -1 --pretty="${message}%n${author}%n${date}" "$1"
  else
    message+="-"
    author+="-"
    date+="-"
    printf "%s\n" "$message" "$author" "$date"
  fi
}

print_changed_files() {
  if [[ $1 == R || $1 == C ]]; then
    print_changed_files_raw "$@" --name-status
  else
    print_changed_files_raw "$@" --name-only
  fi
}

print_changed_files_count() {
  print_changed_files_raw "$@" --name-only | count_nulls
}

print_changed_files_raw() {
  git diff -z --diff-filter "$@"
}

print_untracked_files() {
  git ls-files -z --other --exclude-standard --full-name "$(git rev-parse --show-toplevel)"
}

print_untracked_files_count() {
  print_untracked_files | count_nulls
}

count_nulls() {
  tr --complement --delete '\0' | wc --bytes
}

format_table() {
  column --table --separator="|" --output-separator=" " "$@"
}

format_paths() {
  if [[ $1 == R || $1 == C ]]; then
    local change src_path dst_path

    while IFS= read -r -d '' change \
       && IFS= read -r -d '' src_path \
       && IFS= read -r -d '' dst_path; do

      change=${change:1}
      if [[ $change == 0* ]]; then
        change=${change:1}
        if [[ $change == 0* ]]; then
          change=${change:1}
        fi
      fi

      printf "#%s *%s %s#r|*n|#%s%s#r|#u%s%%#r\n" "$1" "$1" "$src_path" "$1" "$dst_path" "$change"
    done | format_table --table-right=4
  else
    local path
    while IFS= read -r -d '' path; do
      printf "#%s *%s %s#r\n" "$1" "$1" "$path"
    done
  fi
}

replace_formatters() {
  local -A formats=()
  local -A icons=()

  if [[ $colors_on == true ]]; then
    formats[r]=$(tput sgr0)      # Reset
    formats[b]=$(tput bold)      # Bold
    formats[A]="$(tput setaf 2)" # Added
    formats[C]="$(tput setaf 6)" # Copied
    formats[D]="$(tput setaf 1)" # Deleted
    formats[M]="$(tput setaf 4)" # Modified
    formats[R]="$(tput setaf 6)" # Renamed
    formats[T]="$(tput setaf 6)" # Retyped
    formats[U]="$(tput setaf 3)" # Unmerged
    formats[X]="$(tput setaf 5)" # Unknown
    formats[B]="$(tput setaf 5)" # Broken
    formats[u]="$(tput setaf 8)" # Untracked
  else
    formats[r]= # Reset
    formats[b]= # Bold
    formats[A]= # Added
    formats[C]= # Copied
    formats[D]= # Deleted
    formats[M]= # Modified
    formats[R]= # Renamed
    formats[T]= # Retyped
    formats[U]= # Unmerged
    formats[X]= # Unknown
    formats[B]= # Broken
    formats[u]= # Untracked
  fi

  if [[ $icons_on == true ]]; then
    icons[l]="ﲾ " # Local
    icons[r]="歷"  # Remote
    icons[g]=" " # Changes
    icons[h]="  " # Branch
    icons[a]="  " # Ahead
    icons[b]="  " # Behind
    icons[e]="  " # State
    icons[s]="  " # Stash
    icons[c]="  " # Commit
    icons[m]="  " # Message
    icons[o]="  " # Author
    icons[d]="  " # Date
    icons[w]=" פּ"  # Work tree
    icons[i]=" "  # Index
    icons[t]="" # Change type
    icons[A]="" # Added
    icons[C]="" # Copied
    icons[D]="" # Deleted
    icons[M]="" # Modified
    icons[R]="" # Renamed
    icons[T]="" # Retyped
    icons[U]="" # Unmerged
    icons[X]="?" # Unknown
    icons[B]="" # Broken
    icons[u]="" # Untracked
    icons[n]="" # Move
  else
    icons[l]=     # Local
    icons[r]=     # Remote
    icons[h]=     # Branch
    icons[a]=     # Ahead
    icons[b]=     # Behind
    icons[e]=     # State
    icons[s]=     # Stash
    icons[c]=     # Commit
    icons[m]=     # Message
    icons[o]=     # Author
    icons[d]=     # Date
    icons[g]=     # Changes
    icons[w]=" W" # Work tree
    icons[i]=" I" # Index
    icons[t]="T"  # Change type
    icons[A]="A"  # Added
    icons[C]="C"  # Copied
    icons[D]="D"  # Deleted
    icons[M]="M"  # Modified
    icons[R]="R"  # Renamed
    icons[T]="T"  # Retyped
    icons[U]="U"  # Unmerged
    icons[X]="X"  # Unknown
    icons[B]="B"  # Broken
    icons[u]=" "  # Untracked
    icons[n]="->" # Move
  fi

  local sed_opts=()
  local name

  for name in "${!formats[@]}"; do
    sed_opts+=("--expression" "s/#$name/${formats[$name]}/g")
  done

  for name in "${!icons[@]}"; do
    sed_opts+=("--expression" "s/*$name/${icons[$name]}/g")
  done

  sed "${sed_opts[@]}"
}

main "$@"
