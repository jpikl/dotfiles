#!/usr/bin/env bash

set -euo pipefail
shopt -s extglob

source ~/.local/lib/bash/core.sh
source ~/.local/lib/bash/format.sh
source ~/.local/lib/bash/path.sh

readonly COVER_ART=cover.jpg

help() {
  cat <<-EOT
		Check structure of music directory.

		Usage:
		  $(self) [<options>] [<directory>]

		Args:
		  <directory> Music directory to process.
		              Defaults to the USER_MUSIC_DIR environment variable.

		Options:
		  -s  Simplified structrure (implies -RYAC).
		  -R  Do not use root directories.
		  -Y  Do not use album years.
		  -A  Allow single-track albums without parent directory.
		  -C  Allow missing cover arts.
		  -v  Verbose error reporting.
		  -h  Print this help.

		The following directory structure is expected:

		  <letter>/
		  <letter>/<artist>/
		  <letter>/<artist>/<year> - <album>/
		  <letter>/<artist>/<year> - <album>/<number> - <title>.<extension>
		  <letter>/<artist>/<year> - <album>/<number> - <title>.<extension>
      ...
		  <letter>/<artist>/<year> - <album>/cover.jpg
		  ...

		For example:

		  I/
		  I/Iron Maiden/
		  I/Iron Maiden/1984 - Powerslave/
		  I/Iron Maiden/1984 - Powerslave/01 - Aces High.mp3
		  I/Iron Maiden/1984 - Powerslave/02 - 2 Minutes to Midnight.mp3
		  ...
		  I/Iron Maiden/1984 - Powerslave/cover.jpg
		  ...

		When -R option is used, the root <letter> is ommited:

		  <artist>/<year> - <album>/<number> - <title>.<extension>

		When -Y option is used, the album <year> is ommited:

		  <letter/><artist>/<album>/<number> - <title>.<extension>

		When -A option is used, album can be a single track without directory:

		  <letter/><artist>/<year> - <album>.<extension>
	EOT
}

main() {
  local roots_enabled=true
  local years_enabled=true
  local album_dirs_required=true
  local cover_art_required=true
  local verbose=false
  local opt

  while getopts ":sRYACvh" opt; do
    case "$opt" in
      s) roots_enabled=false
         years_enabled=false
         album_dirs_required=false
         cover_art_required=false ;;
      R) roots_enabled=false ;;
      Y) years_enabled=false ;;
      A) album_dirs_required=false ;;
      C) cover_art_required=false ;;
      v) verbose=true ;;
      h) help; exit ;;
      *) die_invalid_opt "$opt" ;;
    esac
  done

  shift $((OPTIND - 1))
  local music_dir

  if [[ $# -gt 0 ]]; then
    music_dir=$(path_make_absolute "$1")
  else
    music_dir=$(path_from_env USER_MUSIC_DIR)
  fi

  if [[ ! -d $music_dir ]]; then
    die "'$music_dir' is not a directory"
  fi

  local path
  local last_error_path
  local error_count

  check_roots && check_artists && check_albums && check_tracks
}

list_at_depth() {
  local depth=$1
  [[ $roots_enabled == false ]] && ((depth--))
  find "$music_dir" -mindepth "$depth" -maxdepth "$depth" | sort
}

check_roots() {
  if [[ $roots_enabled == false ]]; then
    return 0
  fi

  begin_check "roots"

  while IFS= read -r path; do
    if [[ ! -d $path ]]; then
      path_error "Not a directory"
    elif [[ ! ${path##*/} =~ ^[A-Z]$ ]]; then
      path_error "Name is not a single uppercase letter"
    fi
  done < <(list_at_depth 1)

  end_check
}

check_artists() {
  begin_check "artists"

  local -A uniq_names=()

  while IFS= read -r path; do
    if [[ ! -d $path ]]; then
      path_error "Not a directory"
      continue
    fi

    local file=${path##*/}

    if [[ $roots_enabled == true ]]; then
      local dir=${path%/*}
      local parent=${dir##*/}
      local expected_parent=${file:0:1}
      expected_parent=${expected_parent^} # Uppercase

      if [[ $parent != "$expected_parent" ]]; then
        path_error "Wrong parent '$parent', expected '$expected_parent'"
      fi
    fi

    check_name "$file"
    check_uniq_name "$file"
  done < <(list_at_depth 2)

  end_check
}

check_albums() {
  begin_check "albums"

  if [[ $years_enabled == true ]]; then
    local this_year
    this_year=$(date +"%Y")
  fi

  local -A uniq_names
  local prev_dir=

  while IFS= read -r path; do
    if [[ ! -d $path ]]; then
      if [[ $album_dirs_required == true ]]; then
        path_error "Not a directory"
        continue
      elif ! is_audio_file "$path"; then
        path_error "Not an audio file"
        continue
      fi
    fi

    local file=${path##*/}
    local dir=${path%/*}

    if [[ $dir != "$prev_dir" ]]; then
      uniq_names=()
      prev_dir=$dir
    fi

    if [[ $years_enabled == true ]]; then
      # Hello from 2022 if you are fixing this for year > 9999 :P
      if [[ ! $file =~ ^[0-9]{4}' '-' '.+$ ]]; then
        path_error "Does not match pattern '<YEAR> - <ALBUM>'"
        continue
      fi

      local year=${file%% - *}
      local album=${file#* - }

      if [[ $year -lt 1900 || $year -gt "$this_year" ]]; then
        path_error "Suspicious year $year"
      fi
    else
      local album=$file
    fi

    if [[ -f "$path" ]]; then
      album=${album%.*} # Remove extension
    fi

    check_name "$album"
    check_uniq_name "$album"
  done < <(list_at_depth 3)

  end_check
}

check_tracks() {
  begin_check "tracks"

  local album_paths=()
  local prev_dir=

  while IFS= read -r path; do
    local dir=${path%/*}

    if [[ $prev_dir != "$dir" ]]; then
      if [[ $prev_dir ]]; then
        check_tracks_of_album "$prev_dir" "${album_paths[@]}"
      fi
      album_paths=()
      prev_dir=$dir
    fi

    album_paths+=("$path")
  done < <(list_at_depth 4)

  if [[ $prev_dir ]]; then
    check_tracks_of_album "$prev_dir" "${album_paths[@]}"
  fi

  end_check
}

check_tracks_of_album() {
  local dir=$1
  shift

  local path
  local track_count=0

  for path; do
    local file=${path##*/}

    if is_audio_file "$file"; then
      ((++track_count))
    elif [[ $file == "$COVER_ART" ]]; then
      continue
    else
      path_error "Unexpected file"
    fi
  done

  local digits=${#track_count}
  if [[ $digits -lt 2 ]]; then
    digits=2
  fi

  local used_numbers=()
  local number

  for ((number = 0; number <= track_count; number++)); do
    used_numbers[$number]=false
  done

  for path; do
    local file=${path##*/}

    if is_audio_file "$file"; then
      if [[ ! $file =~ ^[0-9]+' '-' '.+$ ]]; then
        path_error "Does not match pattern '<NUMBER> - <TITLE>'"
      else
        local number=${file%% - *}

        if [[ ${#number} -ne $digits ]]; then
          path_error "Number should have $digits digits"
        fi

        number=${number##+(0)} # Remove leading zeros (uses bash extglob)

        if [[ ! ${used_numbers[$number]-} ]]; then
          path_error "Out of range track number $number"
        elif [[ ${used_numbers[$number]} == true ]]; then
          path_error "Duplicit track number $number"
        else
          used_numbers[$number]=true
        fi

        local title=${file#* - }
        title=${title%.*} # Remove extension
        check_name "$title"
      fi
    fi
  done

  path=$dir

  if [[ $cover_art_required == true && ! -f "$dir/$COVER_ART" ]]; then
    path_error "Missing $COVER_ART"
  fi

  local missing_numbers=()
  for ((number = 1; number <= track_count; number++)); do
    if [[ ${used_numbers[$number]} == false ]]; then
      missing_numbers+=("$number")
    fi
  done

  if [[ ${#missing_numbers[@]} -gt 0 ]]; then
    path_error "Missing track numbers: $(list_args "${missing_numbers[@]}")"
  fi
}

check_name() {
  local name=$1

  if [[ $name =~ ^[[:lower:]] ]]; then
    path_error "Should start with an uppercase character"
  fi

  if [[ $name =~ ^[[:space:]] || $name =~ [[:space:]]$ ]]; then
    path_error "Not trimmed"
  fi

  if [[ $name =~ [[:space:]]{2,} ]]; then
    path_error "Consecutive whitespaces"
  fi

  if [[ $name =~ [^[:space:]]-[[:space:]] || $name =~ [[:space:]]-[^[:space:]] ]]; then
    path_error "'-' has uneven spaces on sides"
  fi

  # audiotag/id3 cannot handle square brackets [] in filename
  if [[ $name =~ [\\/\<\>\:\"|?*] || $name == *[* || $name == *]* ]]; then
    path_error "Contains one of forbidden characters /, \, <, >, [, ], :, \", |, ?, *"
  fi

  # Skip capitalization checks after '- ' where uppercase letter is always OK
  name=${name//- /-}

  local word
  local cap_word

  for word in "a" "and" "at" "by" "for" "from" "in" "into" "of" "on" "or" "over" "the" "to" "with"; do
    cap_word=${word^}
    if [[ $name =~ [[:space:]]${cap_word}[[:space:]] ]]; then
      path_error "'$cap_word' should be '$word'"
    fi
  done
}

check_uniq_name() {
  local key=$1
  key=${key,,} # Lowercase
  key=${key//[[:space:]]} # Remove white-spaces

  if [[ ${uniq_names[$key]-} ]]; then
    path_error "Duplicate name '${uniq_names[$key]}'"
  else
    uniq_names[$key]=$1
  fi
}

begin_check() {
  echo "=== ${1^} ==="

  path=
  last_error_path=
  error_count=0
}

end_check() {
  echo
  echo "Errors: $error_count"
  echo
  [[ $error_count -eq 0 ]]
}

path_error() {
  if [[ $path != "$last_error_path" ]]; then
    if [[ $verbose == true || ! $last_error_path ]]; then
      echo
    fi
    last_error_path=$path
    echo "$path"
  fi
  ((++error_count))
  if [[ $verbose == true ]]; then
    echo "  $1"
  fi
}

is_audio_file() {
  [[ $1 == *.mp3 || $1 == *.ogg || $1 == *.m4a ]]
}

main "$@"
