#!/usr/bin/env bash

set -euo pipefail
shopt -s extglob

source ~/.local/lib/bash/core.sh
source ~/.local/lib/bash/path.sh

readonly COVER_IMAGE=cover.jpg

help() {
  cat <<-EOT
		Check structure of music directory.

		Usage:
		  $(self) [<options>] [<directory>]

		Args:
		  <directory> Music directory to process.
		              Defaults to the USER_MUSIC_DIR environment variable.

		Options:
		  -v  Verbose error reporting.
		  -h  Print this help.

		The following directory structure is expected:

		  <letter>/<artist>/<year> - <album>/<number> - <title>.<extension>

		For example:

		  I/Iron Maiden/1984 - Powerslave/01 - Aces High.mp3
		  I/Iron Maiden/1984 - Powerslave/02 - 2 Minutes to Midnight.mp3
		  ...
	EOT
}

main() {
  local verbose=false
  local opt

  while getopts ":vh" opt; do
    case "$opt" in
      v) verbose=true ;;
      h) help; exit ;;
      *) die_invalid_opt "$opt" ;;
    esac
  done

  shift $((OPTIND - 1))
  local music_dir

  if [[ $# -gt 0 ]]; then
    music_dir=$(path_make_absolute "$1")
  else
    music_dir=$(path_from_env USER_MUSIC_DIR)
  fi

  if [[ ! -d $music_dir ]]; then
    die "'$music_dir' is not a directory"
  fi

  local path
  local last_error_path
  local error_count

  check_roots && check_bands && check_albums && check_tracks
}

list_at_depth() {
  find "$music_dir" -mindepth "$1" -maxdepth "$1" | sort
}

check_roots() {
  begin_check "roots"

  while IFS= read -r path; do
    if [[ ! -d $path ]]; then
      path_error "Not a directory"
    elif [[ ! ${path##*/} =~ ^[A-Z]$ ]]; then
      path_error "Name is not a single uppercase letter"
    fi
  done < <(list_at_depth 1)

  end_check
}

check_bands() {
  begin_check "bands"

  local -A uniq_names=()

  while IFS= read -r path; do
    if [[ ! -d $path ]]; then
      path_error "Not a directory"
      continue
    fi

    local file=${path##*/}
    local dir=${path%/*}
    local parent=${dir##*/}
    local expected_parent=${file:0:1}
    expected_parent=${expected_parent^} # Uppercase

    if [[ $parent != "$expected_parent" ]]; then
      path_error "Wrong parent '$parent', expected '$expected_parent'"
    fi

    check_name "$file"
    check_uniq_name "$file"
  done < <(list_at_depth 2)

  end_check
}

check_albums() {
  begin_check "albums"

  local this_year
  this_year=$(date +"%Y")

  local -A uniq_names
  local prev_dir=

  while IFS= read -r path; do
    if [[ ! -d $path ]]; then
      path_error "Not a directory"
      continue
    fi

    local file=${path##*/}
    local dir=${path%/*}

    if [[ $dir != "$prev_dir" ]]; then
      uniq_names=()
      prev_dir=$dir
    fi

    if [[ ! $file =~ ^[0-9]{4}' '-' '.+$ ]]; then
      path_error "Does not match pattern '<YEAR> - <ALBUM>'"
      continue
    fi

    local year=${file:0:4}
    local album=${file:7}

    if [[ $year -lt 1900 || $year -gt "$this_year" ]]; then
      path_error "Suspicious year $year"
    fi

    check_name "$album"
    check_uniq_name "$album"
  done < <(list_at_depth 3)

  end_check
}

check_tracks() {
  begin_check "tracks"

  local album_paths=()
  local prev_dir=

  while IFS= read -r path; do
    local dir=${path%/*}

    if [[ $prev_dir != "$dir" ]]; then
      if [[ $prev_dir ]]; then
        check_tracks_of_album "$prev_dir" "${album_paths[@]}"
      fi
      album_paths=()
      prev_dir=$dir
    fi

    album_paths+=("$path")
  done < <(list_at_depth 4)

  if [[ $prev_dir ]]; then
    check_tracks_of_album "$prev_dir" "${album_paths[@]}"
  fi

  end_check
}

check_tracks_of_album() {
  local dir=$1
  shift

  local path
  local track_count=0

  for path; do
    local file=${path##*/}

    if is_audio_file "$file"; then
      ((++track_count))
    elif [[ $file == "$COVER_IMAGE" ]]; then
      continue
    else
      path_error "Unexpected file"
    fi
  done

  local digits=${#track_count}
  if [[ $digits -lt 2 ]]; then
    digits=2
  fi

  local used_numbers=(false)
  local number

  for ((number = 1; number < track_count; number++)); do
    used_numbers[$number]=false
  done

  for path; do
    local file=${path##*/}

    if is_audio_file "$file"; then
      if [[ ! $file =~ ^[0-9]{${digits}}' '-' '.+$ ]]; then
        path_error "Does not match pattern '<NUMBER($digits digits)> - <TITLE>'"
      else
        local number=${file:0:$digits}
        number=${number##+(0)} # Remove leading zeros (uses bash extglob)
        used_numbers[$number]=true

        local title=${file:((digits + 3))}
        title=${title%.*} # Remove extension
        check_name "$title"
      fi
    fi
  done

  path=$dir

  if [[ ! -f $dir/$COVER_IMAGE ]]; then
    path_error "Missing $COVER_IMAGE"
  fi

  local all_numbers_used=true

  for ((number = 1; number < track_count; number++)); do
    if [[ ${used_numbers[$number]} == false ]]; then
      all_numbers_used=false
      break;
    fi
  done

  if [[ $all_numbers_used == false ]]; then
    for ((number = 1; number < track_count; number++)); do
      if [[ ${used_numbers[$number]} == false ]]; then
        path_error "Missing track #$number"
      fi
    done
  fi
}

check_name() {
  local name=$1

  if [[ $name =~ ^[[:lower:]] ]]; then
    path_error "Should start with an uppercase character"
  fi

  if [[ $name =~ ^[[:space:]] || $name =~ [[:space:]]$ ]]; then
    path_error "Not trimmed"
  fi

  if [[ $name =~ [[:space:]]{2,} ]]; then
    path_error "Consecutive whitespaces"
  fi

  if [[ $name =~ [^[:space:]]-[[:space:]] || $name =~ [[:space:]]-[^[:space:]] ]]; then
    path_error "'-' has uneven spaces on sides"
  fi

  # audiotag/id3 cannot handle square brackets [] in filename
  if [[ $name =~ [\\/\<\>\:\"|?*] || $name == *[* || $name == *]* ]]; then
    path_error "Contains one of forbidden characters /, \, <, >, [, ], :, \", |, ?, *"
  fi

  # Skip capitalization checks after '- ' where uppercase letter is always OK
  name=${name//- /-}

  local word
  local cap_word

  for word in "a" "and" "at" "by" "for" "from" "in" "into" "of" "on" "or" "over" "the" "to" "with"; do
    cap_word=${word^}
    if [[ $name =~ [[:space:]]${cap_word}[[:space:]] ]]; then
      path_error "'$cap_word' should be '$word'"
    fi
  done
}

check_uniq_name() {
  local key=$1
  key=${key,,} # Lowercase
  key=${key//[[:space:]]} # Remove white-spaces

  if [[ ${uniq_names[$key]-} ]]; then
    path_error "Duplicate name '${uniq_names[$key]}'"
  else
    uniq_names[$key]=$1
  fi
}

begin_check() {
  echo "=== ${1^} ==="

  path=
  last_error_path=
  error_count=0
}

end_check() {
  echo
  echo "Errors: $error_count"
  echo
  [[ $error_count -eq 0 ]]
}

path_error() {
  if [[ $path != "$last_error_path" ]]; then
    if [[ $verbose == true || ! $last_error_path ]]; then
      echo
    fi
    last_error_path=$path
    echo "$path"
  fi
  ((++error_count))
  if [[ $verbose == true ]]; then
    echo "  $1"
  fi
}

is_audio_file() {
  [[ $1 == *.mp3 || $1 == *.ogg ]]
}

main "$@"
