#!/usr/bin/env bash

set -euo pipefail

source "$BASH_LIB_DIR/core.sh"

help() {
  cat <<-EOT
		Generate expression for the find command.

		Usage:
		  $(self) [options]

		Options:
		  -G  Exclude .git directories.
		  -P  Exclude project metadata.
		  -L  Exclude libraries.
		  -O  Exclude compilation output.
		  -s  Include source files only. Same as -GPLO.
		  -h  Display this help.

		Examples:
		  Find HEAD files outside .git directory:
		  find \$($(self) -G) -name HEAD

		  Find *.xml files between source files:
		  find \$($(self) -s) -name '*.xml'
	EOT
}

main() {
  local exclude_git=false
  local exclude_project=false
  local exclude_libs=false
  local exclude_compiled=false
  local opt

  while getopts ":GPLOsh" opt; do
    case "$opt" in
      G) exclude_git=true ;;
      P) exclude_project=true ;;
      L) exclude_libs=true ;;
      O) exclude_compiled=true ;;
      s) exclude_git=true
         exclude_project=true
         exclude_libs=true
         exclude_compiled=true
         ;;
      h) help; exit ;;
      *) die_invalid_opt "$opt" ;;
    esac
  done

  local excluded_dirs=()

  if [[ $exclude_git = true ]]; then
    excluded_dirs+=(".git")
  fi

  if [[ $exclude_project = true ]]; then
    excluded_dirs+=(".idea")
  fi

  if [[ $exclude_libs = true ]]; then
    excluded_dirs+=("node_modules" "!dependsrc")
  fi

  if [[ $exclude_compiled = true ]]; then
    excluded_dirs+=("target" ".happypack")
  fi

  if [[ ${#excluded_dirs[@]} -gt 0 ]]; then
    printf -- "-not ( -type d ( -name %s" "${excluded_dirs[0]}"
    if [[ ${#excluded_dirs[@]} -gt 1 ]]; then
      printf -- " -or -name %s" "${excluded_dirs[@]:1}"
    fi
    printf -- " ) -prune )\n"
  fi
}

main "$@"
