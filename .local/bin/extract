#!/usr/bin/env bash

set -euo pipefail

source "$BASH_LIB_DIR/core.sh"

help() {
  cat <<-EOT
		Extract archive in nearly any format.

		Usage:
		  $(self) [options] [--] <file>...

		Options:
		  -f  Force extraction even if output files aready exist.
		  -v  Verbose mode with additional output.
		  -s  Skip extraction errors.
		  -h  Print this help.

		File:
		  One or more files to extract.
	EOT
}

main() {
  local force=false
  local verbose=false
  local skip_errors=false
  local opt

  while getopts ":fvsh" opt; do
    case "$opt" in
      f) force=true ;;
      v) verbose=true ;;
      s) skip_errors=true ;;
      h) help; exit ;;
      *) die_invalid_opt "$opt" ;;
    esac
  done

  shift $((OPTIND - 1))
  [[ $# -eq 0 ]] && die_missing_arg

  local file
  for file; do
    extract "$file"
  done
}

extract() {
  echo "Extracting '$1'"

  if [[ ! -f "$1" ]]; then
    handle_error "'$1' is not a file"
    return
  fi

  case "${1,,}" in # To lower case.
    # =============== Tar archives + compression only tools ===============

    *.tar)      extract_tar "$1" ;;

    *.tar.bz)   ;&
    *.tar.bz2)  ;&
    *.tbz)      ;&
    *.tbz2)     extract_tar "$1" "bzip2" ;;

    *.taz)      ;&
    *.tar.gz)   ;&
    *.tar.z)    ;&
    *.tgz)      ;&
    *.tz)       extract_tar "$1" "gzip" ;;

    *.tar.lrz)  ;&
    *.tlrz)     extract_tar "$1" "lrzip" ;;

    *.tlz4)     ;&
    *.tar.lz4)  extract_tar "$1" "lz4" ;;

    *.tar.lz)   ;&
    *.tlz)      extract_tar "$1" "lzip" ;;

    *.tar.lzma) ;&
    *.tlzma)    extract_tar "$1" "lzma" ;;

    *.tar.lzo)  ;&
    *.tar.lzop) ;&
    *.tlzo)     ;&
    *.tlzop)    extract_tar "$1" "lzop" ;;

    *.tar.xz)   ;&
    *.txz)      extract_tar "$1" "xz" ;;

    *.tar.zst)  ;&
    *.tzst)     extract_tar "$1" "zst" ;;

    # =============== Compression only tools ===============

    *.bz)   ;&
    *.bz2)  extract_compression "$1" "bzip2";;

    *.gz)   ;&
    *.z)    extract_compression "$1" "gzip";;

    *.lrz)  extract_compression "$1" "lrzip" ;;
    *.lz4)  extract_compression "$1" "lz4" ;;
    *.lz)   extract_compression "$1" "lzip" ;;
    *.lzo)  extract_compression "$1" "lzop" ;;
    *.lzma) extract_compression "$1" "lzma" ;;
    *.xz)   extract_compression "$1" "xz" ;;
    *.zst)  extract_compression "$1" "zstd" ;;

    # =============== Archiving and compression tools ===============

    *.7z)  extract_7z  "$1" ;;
    *.rar) extract_rar "$1" ;;

    *.aar) ;&
    *.apk) ;&
    *.ipsw) ;&
    *.jar) ;&
    *.sublime-package) ;&
    *.war) ;&
    *.whl) ;&
    *.xpi) ;&
    *.zip) extract_zip "$1" ;;

    # =============== Everything else ===============

    *) handle_error "'$1' has unsupported archive extension" ;;
  esac
}

extract_tar() {
  local opts=(
    "--extract" # Do extraction.
    "--file=$1" # Use the input file.
  )

  # Filter data through a compression program.
  if [[ ${2-} ]]; then
    if [[ $2 =~ lrzip|lz4 ]]; then
      local cmd=$2
      [[ $verbose = false ]] && cmd+=" --quiet" # Works for both lrzip and lz4.
      opts+=("--use-compress-program=$cmd")
    else
      opts+=("--$2") # Tar supports compression program natively.
    fi
  fi

  if [[ $force = true ]]; then
    opts+=("--overwrite") # Overwrite existing files.
  else
    opts+=("--keep-old-files") # Don't replace existing files, treat them as errors.
  fi

  if [[ $verbose = true ]]; then
    opts+=("--verbose") # Verbose output.
  fi

  tar "${opts[@]}" || handle_error
}

extract_compression() {
  local output=${1%.*} # Remove input extension.
  if [[ -f "$output" && $force == false ]] && ! confirm "Overwrite '$output'?"; then
      return
  fi

  local opts=(
    "--decompress" # Do decompression.
    "--force"      # Overwrite an existing output file.
  )

  if [[ $2 != lrzip ]]; then
    opts+=("--keep") # Don't delete the input file.
  fi

  if [[ $verbose = true ]]; then
    opts+=("--verbose") # Verbose output.
  else
    opts+=("--quiet") # Quiet mode.
  fi

  "$2" "${opts[@]}" "$1" || handle_error
}

extract_7z() {
  local opts=("x") # Do extraction.

  if [[ $force = true ]]; then
    opts+=("-aoa") # Overwrite existing files without prompting.
  fi

  if [[ $verbose = false ]]; then
    # 7z does not have an option to be completely silent.
    # We would have to redirect its output to /dev/null, however
    # there is no way to redirect confirmation messages to stderr.
    opts+=("-bb0" "-bd") # Disable log and progress indicator.
  else
    opts+=("-bb3") # Log everything.
  fi

  if [[ $verbose = false && $force = true ]]; then
    # In this particular case, where no confirmation is needed,
    # we can safely redirect all output to /dev/null.
    7z "${opts[@]}" "$1" >/dev/null || handle_error
  else
    7z "${opts[@]}" "$1" || handle_error
  fi
}

extract_rar() {
  local opts=("x") # Do extraction.

  if [[ $force = true ]]; then
    opts+=("-o+") # Overwrite existing files without prompting.
  fi

  if [[ $verbose = false ]]; then
    opts+=("-idq") # Quiet mode.
  fi

  unrar "${opts[@]}" "$1" || handle_error
}

extract_zip() {
  local opts=()

  if [[ $force = true ]]; then
    opts+=("-o") # Overwrite existing files without prompting.
  fi

  if [[ $verbose = false ]]; then
    opts+=("-qq") # Very quiet mode.
  fi

  unzip "${opts[@]}" "$1" || handle_error
}

handle_error() {
  [[ ${1-} ]] && alert "$1" >&2
  [[ $skip_errors = true ]] || die
}

main "$@"
